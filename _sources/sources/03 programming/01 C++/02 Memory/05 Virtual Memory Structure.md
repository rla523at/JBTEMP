# Virtual Memory Structure
가상 메모리는 분할되어 있으며, 각각의 분할된 공간을 `파티션(partition)`이라고 한다. 주소 공간의 분할 방식은 운영체제의 구현 방식에 따라 서로 다를 수 있으며 윈도우 계열에서도 커널이 달라지면 그 구조가 조금씩 달라지곤 한다.

32비트 시스템은 아래와 같이 분할되어 있다.

* Null 포인터 할당 파티션 : 0x00000000 ~ 0x0000FFFF
* 유저 모드 파티션 : 0x00010000 ~ 0x7FFEFFFF
* 64KB 접근 금지 파티션 : 0x7FFF0000 ~ 0x7FFFFFF
* 커널 모드 파티션 : 0x80000000 ~ 0xFFFFFFFF

윈도우에서는 운영체제 자체가 소유하고 있는 파티션에 접근을 금지한다. 이는 특정 프로세스의 수행 중인 쓰레드가 운영체제의 데이터에 접근하는 것이 불가능함을 의미한다. 따라서 사용자는 유저 모드 파티션(약 2GB)만 사용할 수 있다.

> Reference  
> {cite}`FundamentalC++`

## Null 포인터 할당 파티션
0x00000000 ~ 0x0000FFFF(크기 64KB) 주소공간의 파티션은 프로그래머가 NULL 포인터 할당 연산을 수행할 경우를 대비하기 위해 준비된 영역이다. 만일 프로세스의 특정 쓰레드가 이 파티션에 대해 읽거나 쓰기를 시도하게 되면 `접근 위반(access violation)`이 발생한다.

```cpp
    int* ptr = nullptr; //NULL 포인터 할당 파티션 접근!!    
    *ptr = 1000;         //쓰기 acess 위반
    int a = *ptr;        //읽기 acess 위반
```

## 유저모드 파티션
프로세스의 주소 공간 내에서 유일하게 자유롭게 활용될 수 있는 파티션이다. 0x00010000 ~ 0x7FFEFFFF의 범위이므로, 2047MB의 크기이다. 모든 애플리케이션에 대해 프로세스가 유지해야 되는 대부분의 데이터가 저장되는 영역이며, EXE, DLL 파일이 이 파티션에 로드된다.

유저모드 파티션은 다시 code영역, Data 영역 5가지로 나눌 수 있다.

## Code 영역
`텍스트 영역(text segment)`이라고도 불리는 `코드 영역(code segment)`은 실행 될 명령어가 저장 되어 있는 영역으로 CPU는 이 영역에 저장된 명령어를 하나씩 가져가서 처리한다. 또한 모든 함수는 code 영역에 저장된다. 이 영역은 오직 읽기만 가능한데, 쓰기가 금지된 이유는 코드의 안정성을 위해서이다. 만일 이 영역에 쓰기가 가능하다면 악의적인 목적으로 실행 코드 자체를 변조할 수 있다.

### Data 영역
Data 영역은 초기화된 전역 객체가 저장되는 곳이다. 이 영역의 크기는 컴파일 시 결정되며 런타임에 바뀌지 않는다. 세부적으로는 read only data 영역과 read/write data 영역으로 구분된다. read only data(.rodata) 영역은 상수 전역 변수가 저장되는 영역이다. 하지만 반드시 모든 상수 전역 변수가 .rodata에 저장되는 것은 아니며 .text에 저장되기도 한다. 이는 컴파일러 구현에 달려있다.

#### 참고
[Data 영역 구분 stack over flow](https://stackoverflow.com/questions/39252410/use-of-readonly-memory-in-data-segment)  

### BSS 영역
`block starting symbol (BSS)` 영역은 초기화 되지 않은 전역 객체가 저장되는 곳이다. 초기화되지 않았다고 해서 쓰레기 값이 들어있는 것은 아니고 일반적으로 메모리가 모두 0으로 채워진다.

초기화 여부는 객체 자체의 내용을 저장하느냐, 빈 객체가 있다는 사실을 저장하느냐의 차이다. 실행 파일의 데이터 영역에는 실제 초기화된 값들이 저장되어 있지만, 실행 파일의 BSS 영역에는 어떤 객체들이 필요한지가 저장되어 있다.

만약 실행 파일에 초기화되지 않은 32MB 크기의 배열 객체가 있다고 가정해보자. 이것을 그대로 저장한다면 실행 파일은 32MB 이상이 될 것이다. 이것은 무척 낭비가 심하다. 실행 파일의 BSS 영역에는 단지 "32MB 크기의 초기화되지 않은 배열 객체가 있다."는 정보만 기록하고 있으면 된다. 따라서 32MB의 크기를 포함할 필요가 없다.

이제 프로세스가 시작되면서 실행 파일의 내용이 가상 메모리에 올라가게 된다. OS는 실행 파일의 Code와 Data영역에 해당하는 부분을 그대로 가상 메모리에 복사하지만, BSS 영역에 해당하는 부분에 대해서는 조금 다른 처리를 수행한다. 배열 객체의 크기인 32MB의 메모리를 확보하고 0으로 채워 넣는 것이다. 초기화 되지 않은 전역 객체는 수없이 많을 수 있다. 따라서 하나의 영역에 몰아놓고, 통째로 해당 영역을 0으로 초기화하는 것이 효율적이다. 그래서 초기화되지 않은 전역 객체에 대해서는 하나의 영역을 만들게 된 것이고, 그것이 바로 가상 메모리의 BSS 영역이다.

> Reference  
> {cite}`FundamentalC++`

### Heap 영역
Heap 영역은 동적 메모리가 저장되는 곳이다. 따라서 heap 영역의 크기는 런 타임(run time)에 사용자가 동적 할당하는 메모리 크기에 의해 결정된다. 이렇게 런 타임에 메모리를 할당받는 것을 메모리의 `동적 할당(dynamic allocation)`이라고 한다.

### Stack 영역
Stack 영역은 스레드당 하나씩 생성된다. 컴파일러 설정에 따라 다를 수 있지만 보통 기본적으로 스레드당 1MB~4MB 정도의 가상 메모리 영역이 스레드 Stack 공간으로 예약된다. 스레드가 생성되는 순간 운영체제는 가상 메모리의 남은 영역 중에서 적당한 곳을 골라서 스레드 Stack으로 예약해준다. Stack에는 스레드가 실행하고 있는 함수의 인자나 지역 변수, 지역 배열 등이 저장된다. Stack 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 이렇게 stack 영역에 저장되는 함수의 호출 정보를 stack 프레임(stack frame)이라고 한다.

stack 영역은 다른 영역들과 달리 높은 주소에서 낮은 주소로 자라나는 형태를 가진다. 이러한 이유는 stack 영역이 엄청나게 커지더라도 운영체제의 핵심인 커널영역을 침범할 수 없게 하기 위해서다. stack 영역에 할당될 메모리의 크기는 컴파일 타임(compile time)에 미리 결정된다.
 
#### 참고
[스택의 최대 할당 크기 - 보즈리 블로그](https://bozeury.tistory.com/90)

## 64KB 접근 금지 영역
유저모드 파티션과 커널 모드 파티션 중간의 64KB 크기 메모리 영역을 정하였다. 이 영역은 Private영역과 Shared영역을 구분하기 위한 완충지대를 둔 것이다. NULL 포인터 영역과 같이 접근을 시도할 경우 Access Violation을 일으킨다.

> Reference  
> {cite}`FundamentalC++`

## 커널 모드 파티션
운영체제를 구성하는 코드들이 위치하며 시세틈 내의 모든 프로세스들이 공유한다. 스레드 스케줄링, 메모리 관리, 파일시스템 지원, 네트워크 지원들을 구현하는 모든 코드와 모든 디바이스 드라이버들이 커널 모드 파티션에 로드된다. 이것은 물리적 메모리에 한 번 로드 되며, 모든 프로세스가 공통으로 사용한다는 뜻인데, 프로세스가 이 영역을 직접 접근하는 것은 막고 있다. API함수를 통하여 얻은 핸들을 통해서만 이 영역을 사용할 수 있다. 프로세스에서 이 주소공간에 읽거나 쓰기를 시도하게 되면 접근 위반이 발생한다. 따라서 이 파티션의 코드와 데이터는 완벽하게 보호된다. 

> Reference  
> {cite}`FundamentalC++`