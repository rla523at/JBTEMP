# Shared Library
정적 라이브러리에는 프로그램 실행에 필요한 모든 코드가 들어가 있기 때문에 환경에 크게 관계 없이 프로그램을 실행 시킬 수 있다. 하지만 이 방식은 몇 가지 문제점들이 있다.

1. 표준 C 라이브러리인 libc 의 경우 많은 프로그램들이 필요로 한다. 그런데 libc 라이브러리에는 C 라이브러리의 모든 함수들의 구현이 들어가 있기 때문에 크기가 매우 크다(약 2MB). 따라서 libc를 프로그램에 정적으로 링크하게 된다면 모든 프로그램의 크기가 최소 2MB가 된다. 심지어 모든 프로그램들이 동일한 libc 라이브러리를 사용하고 있다고 해도 말이다.

2. 물론 요즘 세상에 2 MB 정도야 라고 생각할 수 있다. 하드 디스크는 용량이 크기 때문이다. 하지만 문제는 메모리다. 프로그램이 실행되면 프로그램이 메모리에 로드 되는데, 모든 프로그램들이 똑같은 libc 코드들을 메모리에 올린다면 엄청난 메모리 낭비다. 게다가 메모리는 하드 디스크 보다 훨씬 더 귀한 자원이다.

3. 예를 들어서 새 버전의 libc 나와서 이를 내 시스템에 적용시키고 싶다고 가정하자. 만일 프로그램들이 libc를 정적으로 링킹하고 있다면 이 프로그램들을 모두 다시 컴파일해야 한다.

4. 마지막 문제로 정적 라이브러리 전체를 링킹하면서 사용하지 않는 함수들 까지 전부다 프로그램에 포함된다. 이도 마찬가지로 용량 낭비를 유발한다.

컴퓨터 개발자들은 이러한 문제들을 해결하기 위해 획기적인 방법을 제시한다. 앞서 정적 라이브러리의 가장 큰 문제점은 "모든 프로그램들이 같은 라이브러리를 링킹 하더라도 정적으로 링킹할 경우 프로그램 내에 동일한 라이브러리 코드를 포함해야 한다" 였다. 그렇다면 "많은 프로그램 상에서 사용되는 라이브러리를 컴퓨터 메모리 상에 딱 하나 올려놓고 이를 사용하는 프로그램들이 해당 라이브러리를 공유 하면 어떨까?"는 생각이 바로 공유 라이브러리의 출발이다.

```{figure} _image/0401.png
```

공유 라이브러리를 사용할려면 서로 다른 프로그램이 같은 메모리를 공유할 수 있어야 하는데 각 프로세스들은 다른 프로세스들과 독립적이고 서로 접근할 수 없는 메모리를 갖고 있다. 이러한 문제는 페이지 테이블을 통해 해결한다.

```{figure} _image/0402.png
```

프로세스마다 코드의 크기가 다르기 때문에 공유 라이브러리가 각 프로세스의 가상 메모리에 놓이는 위치가 다르게 된다. 위 그림 처럼 프로세스 1 의 libc 는 0x1234 에, 프로세스 2 의 libc 는 0xABCD 에, 프로세스 3 의 libc 는 0x10 에 놓여 있다. 이 때 위의 그림처럼 각각의 프로세스에는 가상 메모리를 물리 메모리로 변환하는 고유의 페이지 테이블이 있다. 이를 통해 실제 물리 메모리에 libc 코드를 딱 한 군데만 올려 놓고 각 프로세스의 페이지 테이블 내용을 바꿔줌으로써 마치 프로세스 마다 고유의 위치에 libc 코드가 있는 것 처럼 사용할 수 있다. 

그렇다면 한가지 궁금증이 생긴다. "그냥 정적 라이브러리를 공유 라이브러리 처럼 쓰면 안되나?". 

앞서 말했듯이 공유 라이브러리의 경우 프로세스의 가상 메모리 안의 임의의 위치에 로드될 수 있어야 한다. 이런 방식이 가능할지 앞서 만들었던 libfoobar.a 에서의 foo 함수의 어셈블리 코드를 다시 보자.

```
000000000000113d <_Z3foov>:
    113d:	f3 0f 1e fa          	endbr64 
    1141:	55                   	push   %rbp
    1142:	48 89 e5             	mov    %rsp,%rbp
    1145:	e8 16 00 00 00       	callq  1160 <_Z3barv>
    114a:	8b 05 c0 2e 00 00    	mov    0x2ec0(%rip),%eax        ## 4010 <x>
    1150:	83 c0 01             	add    $0x1,%eax
    1153:	89 05 b7 2e 00 00    	mov    %eax,0x2eb7(%rip)        ## 4010 <x>
    1159:	b8 01 00 00 00       	mov    $0x1,%eax
    115e:	5d                   	pop    %rbp
    115f:	c3                   	retq  
```

위 처럼 x 의 값을 읽는 부분에서 실제 x 의 주소값으로 값이 대체된 것을 볼 수 있다. 다시 말해 정적 라이브러리는 외부 링크 방식을 가지는 심볼들을 호출하는 부분이 모두 해당 심볼들의 실제 주소값으로 대체되어 있다. 이 경우 해당 라이브러리 코드를 메모리 임의의 지점에 불러온다면 우리가 원하는 심볼들을 찾을 수 없게 된다.

따라서 공유 라이브러리의 경우 정적 라이브러리와 다른 방식으로 외부 링크 방식을 가지는 심볼들을 불러온다. 그 차이를 알기 위해 먼저 공유 라이브러리를 한 번 만들어보자.

## 공유 라이브러리 만들기
공유 라이브러리는 컴파일러를 통해서 제작할 수 있다. 만약에 원래 하던 것 처럼 foo.cc 와 bar.cc 를 컴파일 해보자.

```
$ g++ -shared foo.o bar.o -o libfoobar.so
/usr/bin/ld: foo.o: relocation R_X86_64_PC32 against symbol `x' can not be used when making a shared object; recompile with -fPIC
/usr/bin/ld: final link failed: bad value
collect2: error: ld returned 1 exit status
```

그렇다면 위와 같은 오류 메세지를 볼 수 있다. 오류 메세지를 그대로 해석해보면 x 심볼에 적용된 R_X86_64_PC32 방식은 공유 라이브러리를 만드는데 사용할 수 없다는 의미이다. 

한 번 objdump 로 x 심볼이 사용되는 foo.o 의 재배치 방식을 살펴보자.

```
 objdump -Sr foo.o

foo.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <_Z3foov>:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	e8 00 00 00 00       	callq  d <_Z3foov+0xd>
			9: R_X86_64_PLT32	_Z3barv-0x4
   d:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        ## 13 <_Z3foov+0x13>
			f: R_X86_64_PC32	x-0x4
  13:	83 c0 01             	add    $0x1,%eax
  16:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        ## 1c <_Z3foov+0x1c>
			18: R_X86_64_PC32	x-0x4
  1c:	b8 01 00 00 00       	mov    $0x1,%eax
  21:	5d                   	pop    %rbp
  22:	c3                   	retq   
  ```

실제로 x 심볼을 참조하는 부분에서 R_X86_64_PC32 방식을 사용하고 있는 것을 알 수 있다. 그렇다면 왜 R_X86_64_PC32 재배치 방식을 공유 라이브러리를 만드는데 사용할 수 없을까? 그 이유는 R_X86_64_PC32 방식을 계산할 때 S + A - P 를 사용하는데 공유 라이브러리의 경우 임의의 위치에 라이브러리가 위치할 수 있기 때문에 섹션의 위치를 특정할 수 없다. 따라서 S + A - P 의 값 자체를 계산할 수 가 없게 된다.

따라서 결국에는 foo.cc 와 bar.cc 를 다시 컴파일 해야 한다. 이 때 컴파일 시에 인자로 `위치와 무관한 코드 (position independent code,PIC)` 를 만들라는 의미의 -fpic 인자를 전달해야 한다.

```
$ g++ -c -fpic foo.cc
$ g++ -c -fpic bar.cc
$ g++ -shared foo.o bar.o -o libfoobar.so
```

이를통해 공유 라이브러리인 libfoobar.so 가 잘 생성된 것을 볼 수 있다. 참고로 리눅스에선 보통 공유 라이브러리의 확장자로 so (shared object)를 사용한다. 

그렇다면 libfoobar.so 한 번 간단한 프로그램에 링크해서 사용해 보자.

```cpp
#include "bar.h"
#include "foo.h"

int main() {
  bar();
  foo();
}
```

링크도 이전과 같이 하면 된다.

```
$ g++ main.cc libfoobar.so -g -o main

```

이때 main의 내용은 어떻게 생겼는지 objdump로 확인해보자.

```
objdump -S main

main:     file format elf64-x86-64

Disassembly of section .plt:

0000000000001020 <.plt>:
    1020:	ff 35 92 2f 00 00    	pushq  0x2f92(%rip)        ## 3fb8 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	f2 ff 25 93 2f 00 00 	bnd jmpq *0x2f93(%rip)        ## 3fc0 <_GLOBAL_OFFSET_TABLE_+0x10>
    102d:	0f 1f 00             	nopl   (%rax)
    1030:	f3 0f 1e fa          	endbr64 
    1034:	68 00 00 00 00       	pushq  $0x0
    1039:	f2 e9 e1 ff ff ff    	bnd jmpq 1020 <.plt>
    103f:	90                   	nop
    1040:	f3 0f 1e fa          	endbr64 
    1044:	68 01 00 00 00       	pushq  $0x1
    1049:	f2 e9 d1 ff ff ff    	bnd jmpq 1020 <.plt>
    104f:	90                   	nop

Disassembly of section .plt.sec:

0000000000001060 <_Z3foov@plt>:
    1060:	f3 0f 1e fa          	endbr64 
    1064:	f2 ff 25 5d 2f 00 00 	bnd jmpq *0x2f5d(%rip)        ## 3fc8 <_Z3foov>
    106b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000001070 <_Z3barv@plt>:
    1070:	f3 0f 1e fa          	endbr64 
    1074:	f2 ff 25 55 2f 00 00 	bnd jmpq *0x2f55(%rip)        ## 3fd0 <_Z3barv>
    107b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

Disassembly of section .text:

0000000000001169 <main>:
int main() {
    1169:	f3 0f 1e fa          	endbr64 
    116d:	55                   	push   %rbp
    116e:	48 89 e5             	mov    %rsp,%rbp
  bar();
    1171:	e8 fa fe ff ff       	callq  1070 <_Z3barv@plt>
  foo();
    1176:	e8 e5 fe ff ff       	callq  1060 <_Z3foov@plt>
}
    117b:	b8 00 00 00 00       	mov    $0x0,%eax
    1180:	5d                   	pop    %rbp
    1181:	c3                   	retq   
    1182:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1189:	00 00 00 
    118c:	0f 1f 40 00          	nopl   0x0(%rax)
```

참고로 위 코드는 전체 objdump로 출력된 부분에서 설명에서 필요한 부분만 잘라낸 것이다.

흥미롭게도, 이전에 정적으로 링크했을 경우와는 다르게 foo 나 bar 의 내용이 전혀 없음을 알 수 있다. foo 나 bar 의 내용이 없는데 그러면 main 은 foo 와 bar 함수를 어떻게 호출하고 있을까?

신기하게도

```
  bar();
    1171:	e8 fa fe ff ff       	callq  1070 <_Z3barv@plt>
  foo();
    1176:	e8 e5 fe ff ff       	callq  1060 <_Z3foov@plt>
```

위와 같이 foo 나 bar 을 직접 호출하는 대신에 (어차피 호출할 수 도 없다.), PLT 섹션에 있는 foo@plt 와 bar@plt 를 호출하고 있습니다. 그렇다면 이들은 어떻게 정의되어 있을까?

```
0000000000001060 <_Z3foov@plt>:
    1060:	f3 0f 1e fa          	endbr64 
    1064:	f2 ff 25 5d 2f 00 00 	bnd jmpq *0x2f5d(%rip)        ## 3fc8 <_Z3foov>
    106b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000001070 <_Z3barv@plt>:
    1070:	f3 0f 1e fa          	endbr64 
    1074:	f2 ff 25 55 2f 00 00 	bnd jmpq *0x2f55(%rip)        ## 3fd0 <_Z3barv>
    107b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
```

`jmpq *0x2f5d(%rip)` 명령어에 의미는, "rip + 0x2f5d 위치에 써져 있는 주소값으로 점프해라"라는 의미이다. 위 경우 rip + 0x2f5d 가 0x3FC8 이므로 0x3FC8 의 위치에 무엇이 써져 있는지 살펴 보자. 이를 위해서 objdump 에 -s 를 주고 실행해보면 모든 섹션들의 데이터를 볼 수 있다.

```
$ objdump -s main
... (생략) ...
Contents of section .got:
 3fb0 a03d0000 00000000 00000000 00000000  .=..............
 3fc0 00000000 00000000 30100000 00000000  ........0.......
 3fd0 40100000 00000000 00000000 00000000  @...............
 3fe0 00000000 00000000 00000000 00000000  ................
 3ff0 00000000 00000000 00000000 00000000  ................
```

여기서 0x3FC8 부분에 무엇이 써져 있는지 보면 리틀 엔디안임을 감안해서 0x1030 임을 알 수 있다. 다시 말해 위 문장은 jmpq 0x1030 과 동일한 의미이다. 마찬가지로 bar 부분을 보면 0x3FD0 에 써져 있는 주소값으로 점프하라는 의미 인데, 해당 부분에는 0x1040 이 쓰여 있다. 따라서 main 에서 bar@plt 를 호출하게 되면 0x1040 으로 점프하게 된다.

그렇다면 0x1040 에는 뭐가 있을까?

```
0000000000001020 <.plt>:
    1020:	ff 35 92 2f 00 00    	pushq  0x2f92(%rip)        ## 3fb8 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:	f2 ff 25 93 2f 00 00 	bnd jmpq *0x2f93(%rip)        ## 3fc0 <_GLOBAL_OFFSET_TABLE_+0x10>
    102d:	0f 1f 00             	nopl   (%rax)
    1030:	f3 0f 1e fa          	endbr64 
    1034:	68 00 00 00 00       	pushq  $0x0
    1039:	f2 e9 e1 ff ff ff    	bnd jmpq 1020 <.plt>
    103f:	90                   	nop
    1040:	f3 0f 1e fa          	endbr64 
    1044:	68 01 00 00 00       	pushq  $0x1
    1049:	f2 e9 d1 ff ff ff    	bnd jmpq 1020 <.plt>
    104f:	90                   	nop
```

0x1040 이후에 스택에 1을 푸시하고 PLT 맨 위로 점프한다. 그리고 다시 스택에 0x2f92(%rip)를 푸시하고, *0x2f93(%rip)로 점프한다. 

무슨 일이 일어나고 있는지 아래 그림을 보면서 이해해보자.

```{figure} _image/0403.png
```

가장 먼저 main 함수에서 공유 라이브러리 안에 있는 bar 함수를 호출한다. 만일 bar가 정적으로 링크된 라이브러리의 함수였다면 그냥 bar가 정의된 위치를 호출하면 된다. 하지만 공유 라이브러리의 경우 프로그램 어디에 위치 되었는지 알 수 없기 때문에 해당 함수를 직접 호출하는 것은 불가능하다.

따라서 어떤 방식을 취하게 되냐면 `global offset table (GOT)`라는 이름의 데이터 테이블을 프로그램 내부에 만든 다음에, 실제 함수들의 주소값을 이 테이블에 적어 놓는다. 그리고 우리가 함수를 호출하게 되면 해당 함수의 실제 위치를 이 테이블을 통해서 알아낸다.

예를 들어서 bar 함수가 GOT에 두 번째 위치에 (GOT[1]) 써져 있다고 가정 해보자. 그렇다면 그냥 call *GOT[1] 을 하게 되면 bar 함수를 호출할 수 있는 것이다. 하지만 프로그램을 처음 실행한 상태에서는 bar 함수가 어디에 위치할 지 알 수 없기 때문에 GOT[1]에 bar의 위치를 써 넣을 수 없다. 따라서 이를 위해서 처음에 GOT[1 에 bar의 실제 위치를 알아낸 후 해당 주소값을 GOT[1] 자리에 덮어 씌우는 함수를 쓴다.

이를 순서대로 정리해보자.

1. 먼저 main에서 bar을 호출 시켜주는 함수인 bar@plt를 호출한다.

2. bar@plt는 GOT에서 bar에 해당하는 엔트리인 GOT[1]로 점프한다.

3. bar가 처음 호출된 상황이므로 GOT[1]에는 bar 의 주소값이 들어 있지 않다. 따라서 `프로시져 링킹 테이블(procedure linkage table, PLT)`안에 정의된 bar 의 실제 위치를 찾는 루틴으로 점프한다. 참고로 PLT는 링크 타임 시에 위치를 알 수 없는 함수들의 위치를 찾아내주는 루틴들을 모아놓은 테이블이다.

4. bar의 GOT상의 위치는 1이므로, 스택에 1을 푸시한 뒤, 해당 심볼의 위치를 찾는 루틴으로 점프한다. 해당 루틴은 보통 PLT 맨 상단에 정의되어 있다.

5. 해당 루틴에선 곧바로 `동적 로더(dynamic loader)` 라이브러리 코드로 점프한다. 라이브러리에서 우리가 원하는 bar 함수가 어디에 정의되어 있는지 찾는다. 참고로 왜 3에서 5로 바로 점프할 수 없냐 궁금할 수 있는데 일단 동적 로더 자체도 공유 라이브러리이고 GOT의 위치를 전달해야 하기 때문이다.

6. 참고로 리눅스의 경우 ld.so 라는 이름의 동적 로더를 사용하고 있다. ld.so는 필요로 하는 심볼을 찾은 뒤 해당 GOT 위치를 업데이트 한다. 따라서 GOT[1]에는 이제 bar의 실제 주소값이 들어간다. 어떤 로더를 사용할지는 프로그램의 interop 섹션에 정의되어 있다.

7. 마지막으로 bar 함수로 점프합니다.

그렇다면 만약에 두 번째로 bar을 호출하게 된다면 어떻게 되는지 살펴보자.

이제는 GOT[1]안에 bar의 주소값이 들어 있기 때문에 복잡한 루틴 필요 없이 그냥 바로 bar을 호출할 수 있다.

이와 같이 함수가 실행 될 때 GOT 엔트리에 등록되는 방식을 `lazy binding` 이라고 한다.

Lazy binding의 장점은 만약에 bar가 프로그램 상에서 한 번도 호출되지 않았다면 bar 의 위치를 찾을 필요가 없다는 점이다. 동적 라이브러리에서 사용하는 함수의 위치를 찾는 작업은 결코 공짜가 아니기에 시간을 절약할 수 있다.

그 대신 lazy binding의 문제로는 해당 함수를 첫 번째로 실행하는 시점에서 많은 시간이 소요된다는 점이다. 따라서 프로그램이 실행 중에 뜨문 뜨문 렉이 걸리는 상황이 발생할 수 있다. 상황에 따라 프로그램 시작 시에 모든 동적으로 바인딩 되는 심볼들을 찾아버리는 것이 오히려 나을 수 도 있다.

따라서 프로그램에 따라서 ld로 하여금 lazy binding을 하지 않고 아예 프로그램 시작 시에 모든 심볼들을 GOT 에 등록하라고 설정할 수 도 있다. (예를 들어서 포토샵을 실행해보면 프로그램 시작 시 꽤 오래걸리는데 이게 대부분 공유 라이브러리에서 사용되는 함수들을 찾느라 걸리는 시간이다.)

## 동적 링킹 방식의 재배치
마지막으로 동적 링킹되는 라이브러리에서 재배치가 어떤 식으로 이루어지는지 살펴보자. 

``` cpp
// foo.cc
#include "bar.h"
int x = 1;

int foo() {
  bar();
  x++;
  return 1;
}
```

위 코드를 컴파일 시에 아래와 같이 구성된다.

```
objdump -Sr foo.o

foo.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <_Z3foov>:
#include "bar.h"
int x = 1;

int foo() {
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
  bar();
   8:	e8 00 00 00 00       	callq  d <_Z3foov+0xd>
			9: R_X86_64_PLT32	_Z3barv-0x4
  x ++;
   d:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        ## 14 <_Z3foov+0x14>
			10: R_X86_64_REX_GOTPCRELX	x-0x4
  14:	8b 00                	mov    (%rax),%eax
  16:	8d 50 01             	lea    0x1(%rax),%edx
  19:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        ## 20 <_Z3foov+0x20>
			1c: R_X86_64_REX_GOTPCRELX	x-0x4
  20:	89 10                	mov    %edx,(%rax)
  return 1;
  22:	b8 01 00 00 00       	mov    $0x1,%eax
}
  27:	5d                   	pop    %rbp
  28:	c3                   	retq   
```

먼저 bar 함수를 호출하는 부분부터 보자. R_X86_64_PLT32 방식으로 bar을 재배치 해야 한다고 명시하고 있다. R_X86_64_PLT32의 경우 재배치 주소 계산 방식이 L + A - P 이다. 여기서 A 와 P 는 기존과 동일하고 L 은 PLT의 주소값이다.

그 이유는 당연히도 bar을 직접 호출하는 것이 아니라 PLT에 등록되어 있는 bar을 호출해주는 루틴을 호출해야 하기 때문에 (bar@plt) PLT 섹션의 위치 기준으로 계산되어야 하기 때문이다.

그렇다면 전역 변수인 x는 어떨까? 이 경우 R_X86_64_REX_GOTPCRELX 형태의 재배치 방식을 사용하는데, 이 경우 계산하는 방식은 G + GOT + A - P 입니다. 여기서 G 는 GOT 안에서 해당 심볼 까지의 오프셋을 말하고, GOT 의 경우 GOT 테이블 자체의 오프셋을 의미합니다. 쉽게 말해서 G + GOT 가 프로그램 시작 부터 GOT 안에 정의 되어 있는 해당 심볼 까지의 오프셋이라 보면 된다.

변수의 경우 함수와는 다르게 PLT를 사용할 필요가 없다. 그냥 해당 변수를 GOT 안에 위치시키면 되기 때문이다. 따라서 위 처럼 R_X86_64_REX_GOTPCRELX 재배치 방식을 사용해서 GOT 안에 전역 변수를 정의하는 것을 알 수 있다. 

사실 여기 까지 다룬 재배치 방식 말고도 몇 가지 더 다른 재배치 방식들이 있다. 하지만 여기서 다룬 내용들을 모두 이해했다면 다른 방식들도 큰 무리 없이 이해하실 수 있을 것이며 이 부분에 대해서 더 공부하려면 [x86-64 ABI](https://uclibc.org/docs/psABI-x86_64.pdf) 를 참고하면 된다.

> Reference   
[모두의 코드](https://modoocode.com/319)  
[C++ 표준 문서](http://eel.is/c++draft/lex.phases)