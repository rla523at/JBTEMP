# Name Mangling
앞서 C에서 C++의 함수를 사용하기 위해서는 extern "C" 로 언어 링크 방식을 명시해주어야 한다는 것을 보았다. 그 이유는, 목적파일 생성시 C컴파일러가 함수 이름을 변환하는 방식과 C++컴파일러가 함수 이름을 변환하는 방식이 다르기 때문이다.

일단 C의 경우 함수 이름 변환 자체가 이루어 지지 않는다. 만약에 아래와 같이 func이란 함수를 정의했다고 가정하자.

```cpp
int func(const char* s) {}
```

이를 C 컴파일러가 컴파일 하면 변환된 이름은 그냥 func 임을 알 수 있다.

```
$ nm a.out
0000000000000000 T func
```
참고로 nm 은 목적 파일에 정의되어 있는 심볼들을 모두 출력해주는 프로그램이다.

반면에 똑같은 소스코드를 C++ 컴파일러로 컴파일하게 되면 아래와 같이 함수의 이름이 바뀐것을 알 수 있다.

```
$ nm a.out
0000000000000000 T _Z4funcPKc
```

이와 같이 C++에서는 목적 코드 생성시에 컴파일러가 함수의 이름을 바꾸는 것을 볼 수 있다. 이를 `이름 맹글링(name mangling)`이라 하는데, 맹글링이라는 단어의 뜻이 원래 엉망진창으로 만들다 라는 의미다. 실제로 함수의 이름이 func에서 알아보기 힘든 버전으로 바뀌었다.

이렇게 이름 맹글링을 하는 이유는 C와 다르게 C++에서는 같은 이름의 함수를 정의할 수 있기 때문이다. C++의 경우 일단 함수의 오버로딩을 통해서 인자가 다른 같은 이름의 함수들을 정의할 수 있고 인자와 이름이 모두 똑같더라도 다른 이름 공간에 들어가 있다면 다른 함수로 취급된다. 따라서, 함수의 이름 자체만으로는 어떤 함수를 호출할 지 구분할 수 가 없게 된다.

이름 맹글링을 하게 되면 원래의 함수 이름에 이름 공간 정보와 함수의 인자 타입 정보들이 추가된다. 따라서 같은 이름의 함수일 지라도, 이름 맹글링을 거치고 다면 다른 이름의 함수로 바뀌기 때문에 링킹을 성공적으로 수행할 수 있다.

실제로 아래 함수들의 이름들은 모두 같지만

```cpp
int func(const char* s) {}
int func(int i) {}
int func(char c) {}

namespace n 
{
int func(const char* s) {}
int func(int i) {}
int func(char c) {}
}  // namespace n
```

맹글링 된 이름을 살펴보면 전부다 다른 이름으로 변환된 것을 볼 수 있다.

```
$ nm test.o
000000000000001d T _Z4funcc
000000000000000f T _Z4funci
0000000000000000 T _Z4funcPKc
000000000000004a T _ZN1n4funcEc
000000000000003c T _ZN1n4funcEi
000000000000002d T _ZN1n4funcEPKc
```

참고로 컴파일러마다 이름 맹글링을 하는 방식이 조금씩 다르기 때문에 A 컴파일러에서 생성한 목적 코드를 B 컴파일러가 링킹할 때 문제가 될 수 있다.

C에서 C++의 함수를 호출하기 위해서는 반드시 이름 맹글링이 되지 않는 함수 심볼을 생성해야 한다. 따라서 extern "C" 를 통해서 이 함수는 이름 맹글링을 하지 마! 라고 컴파일러에게 전달할 수 있다.