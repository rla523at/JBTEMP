# Process

## Program
프로그램이란 보조 기억장치(HDD,SSD)에 저장되어 있지만 메모리 공간을 할당 받지 않은 정적인 상태의 파일(명령어와 데이터의 묶음)이다.

## Process
프로세스란 운영체제로부터 독립적인 메모리 공간을 할당 받은 동적인 상태의 파일(명령어와 데이터 묶음)이다.  
이때 프로그램에서 프로세스로의 전환과정은 다음과 같다.
1. 사용자가 프로그램 실행
2. 운영체제가 코드와 데이터를 메모리에 가져오고, 프로세스 제어블록(PCB, Process Control Block) 생성

이후 프로세스는 다음의 과정을 거쳐 실행이 된다.
1. 준비 상태의 프로세스를 준비 리스트에 삽입
2. CPU가 사용 가능한 상태가 되면 CPU 스케쥴러(scheduler)에 의해 선택된 프로세스에게 디스패처(dispatcher)가 CPU를 할당하고 프로세스는 실행 상태로 상태전이(state transition)이 된다. 이 과정을 디스패칭(dispatching)이라 한다.
3. 프로세스가 CPU를 이용해 연산한 후 반납
   1. CPU를 자발적으로 반납 (nonpreemtive scheduling 비선점형 스케쥴링)
   2. 우선순위에 따라 운영체제에 의해 반납 (preemtive scheduling 선점형 스케쥴링)
4. 작업이 끝나지 않았으면 운영체제가 프로세스를 준비 상태로 상태전이
5. 만약 입출력이 완료대기를 기다려야 하는 상황이라면 완료될때까지 블락 상태로 상태전이
6. 입출력이 완료되면 운영체제가 프로세스를 블락 상태에서 준비 상태로 상태전이
7. 운영체제는 다시 준비 리스트에 첫번째에 있는 프로세스를 실행상태로 바꾸고 과정을 반복

만약 프로세스가 여러개의 스레드로 구성되어 있다면 위의 과정에서 프로세스를 스레드로 바꾸어 보면 된다. 즉, 하나의 프로세스에 각 스레드별로 다른 상태(준비,실행,블락)를 가질 수 있다 

> Reference  
> [blog](https://junsday.tistory.com/25).

### PCB
PCB는 프로세스에 대한 정보가 저장된 자료구조이며 운영체제 영역에서 만들어지며  구성요소는 다음과 같다. 

#### 1.PID, Process IDentification   
운영체제가 각 프로세스를 식별하기 위해 부여한 프로세스 식별번호

#### 2.프로세스 상태  
CPU는 프로세스를 빠르게 교체하면서 실행하기 때문에 실행중인 프로세스도 있고 대기 중인 프로세스도 있다. 그런 프로세스의 상태를 저장

#### 3.프로그램 카운터  
CPU가 다음으로 실행할 명령어를 가리키는 값. CPU는 기계어를 한 단위씩 읽어서 처리하는데 프로세스를 실행하기 위해 다음으로 실행할 기계어가 저장된 메모리 주소를 가리키는 값.

#### 4.스케줄링 우선순위  
운영체제가 여러 개의 프로세스가 CPU에서 실행되는 순서를 결정하는 것이 스케줄링이다. 이 스케줄링에서 우선순위가 높으면 먼저 실행될 수 있는데 이를 스케줄링 우선순위라고 한다.

#### 5.권한  
프로세스가 접근할 수 있는 자원을 결정하는 정보이다. 권한이 필요한 이유는 예를들면 안드로이드 아무 앱이나 휴대폰 통화내역을 볼 수 있는 권한을 가지면 이를 악의적으로 이용하는 앱이 등장할 수 있다. 따라서 프로세스마다 어디까지 접근할 수 있는지에 대한 권한이 필요하다.

#### 6.프로세스의 부모와 자식 프로세스  
최초로 생성되는 init 프로세스를 제외하고 모든 프로세스는 부모 프로세스를 복제해서 생성되고 이 계층관계는 트리를 형성한다. 그래서 각 프로세스는 자식 프로세스와 부모프로세스에 대한 정보를 가지고 있다.

#### 7.프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터
프로세스는 실행중인 프로그램이다. 따라서 프로그램에 대한 정보를 가지고 있어야한다. 프로그램에 대한 정보는 프로세스가 메모리에 가지는 자신만의 주소 공간에 저장된다. 이 공간에 대한 포인터 값을 가진다.

#### 8.프로세스에 할당된 자원들을 가리키는 포인터

#### 9.실행문맥(context)
프로세스가 실행상태에서 마지막으로 실행한 프로세서의 레지스터 내용을 담고 있습니다. CPU에 의해 실행되는 프로세스는 운영체제에 의해 계속 교체되는데 교체되었다가 다시 자신의 차례가 되어서 실행될때 중단된적 없고 마치 연속적으로 실행된것처럼하기 위해 이 레지스터 정보를 가지고 있다.

> Reference  
> [blog1](https://velog.io/@cheal3/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C)  
> [blog2](https://bowbowbow.tistory.com/16#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%84%B1)  

### 다수의 실행 흐름
하나의 프로세스는 하나의 실행 흐름만을 가질 수 있다. 이 떄, 다수의 실행 흐름이 필요하여 여러개의 프로세스를 구성한 경우 다음과 같은 문제점이 있다.

1. 독립된 메모리 영역을 가지고 있어 프로세스 간의 복잡한 통신(inter process communication, IPC)가 필요하다.
2. context switching시 기존 프로세스에 할당된 메모리 영역을 저장하고 새로운 프로세스의 메모리 영역을 불러와야 하기 때문에 overhead가 크다.

이를 해결하기 위해 나온 개념이 스레드이다.

> Reference  
> [blog](https://so-what-93.tistory.com/41) -> 여기 보고 추가로 정리하기  

## 멀티테스킹
하나의 CPU에서 운영체제의 스케쥴링에 따라 여러 프로세스를 번갈아 가며 실행을 이용하여 `동시성(concurrency)` 있게 처리함. 여기서 동시성이란, 물리적인 시간의 동시성이 아니라 사용자 입장에서 마치 동시에 처리되는 것처럼 느껴 진다는 의미이다.

멀티 테스킹시 한 프로세스에서 발생한 입출력 함수(I/O)를 기다리느라 CPU가 연산하지 않고 I/O가 끝날때 까지 대기하는 비효율이 발생한다. 이를 해결하고 CPU의 이용률을 높이기 위해 사용하는 스케쥴링 방식에는 멀티 프로그래밍 시스템과 시분할 시스템 방식이 있다.

### 멀티 프로그래밍 시스템
한 프로세스에서 I/O를 호출했을 때 I/O 장치에 데이터가 없을 경우 다른 프로세스로 context switching이 일어난다. 이후 I/O 장치에 데이터가 도착했을 경우, 우선순위에 따라 context switching이 발생한다.  
따라서 멀티 프로그래밍 시스템에서 context switching이 발생하는 상황은 다음과 같다.
1. 현재 실행 중인 프로세스의 종료
2. 현재 실행 중인 프로세스의 I/O로 인한 대기
3. I/O 장치에 기다리던 데이터 도착

장점
* time slice에 의한 CPU스위칭이 없어 CPU 이용률이 최대화된다.

### 시분할 시스템
멀티 프로그래밍 시스템이 context switching이 발생하는 상황에 추가로 프로세스가 일정 시간(time quantum, time slice)이상 CPU를 사용하는 경우에도 context switching이 발생한다.  

context switching 발생 상황
1. 현재 실행 중인 프로세스의 종료
2. 현재 실행 중인 프로세스의 I/O로 인한 대기
3. I/O 장치에 기다리던 데이터 도착
4. tie slice동안 I/O 없이 계속 실행된 경우

장점
* time slice에 의한 CPU 스위칭이 발생해 번갈아가면서 프로그램을 계속 실행하여 사용자 응답성이 높아진다.

## 멀티 프로세싱
하나 이상의 프로세스를 여러개의 CPU가 `병렬적(parallelism)`으로 작업하는 것